#+TITLE: Outreach Portal
#+AUTHOR: VLEAD
#+DATE: [2015-10-27 Tue]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ./org-templates/level-0.org
#+options: ^:nil


* Introduction
  Outreach portal keeps track of all the outreach activities done to
  promote Virtual Labs. It also acts as a central place where all the
  documents related to workshops/trainings are stored.

* Requirements
<<<<<<< HEAD
  This release (outreach portal - admin release), fulfills the
  following requirements:

  1. Python API that acts as a wrapper to make CRUD operations on the
     entities - users, roles and workshop_documents.
  2. REST API for various applications to perform CRUD operations on
     the entities - users, roles and workshop_documents.
  
* Design & Implementation  
** Some initialization and boilerplate code
*** __init__
#+BEGIN_SRC python :tangle src/__init__.py :eval no
print "src package"
import db

#+END_SRC
*** imports
#+BEGIN_SRC python :tangle src/db.py :eval no
# -*- coding: utf-8 -*-

from collections import OrderedDict

from flask.ext.sqlalchemy import SQLAlchemy
from flask import current_app

import sqlalchemy.types as types

import re
from urlparse import urlparse
from datetime import datetime
import json

from op_exceptions import AttributeRequired
from utils import typecheck

db = SQLAlchemy()


# Abstract class to hold common methods
class Entity(db.Model):

    __abstract__ = True

    # save a db.Model to the database. commit it.
    def save(self):
        db.session.add(self)
        db.session.commit()

    # update the object, and commit to the database
    def update(self, **kwargs):
        for attr, val in kwargs.iteritems():
            setter_method = "set_" + attr
            try:
                self.__getattribute__(setter_method)(val)
            except Exception as e:
                raise e

        self.save()

    #print "Setting new val"
    #print "Calling %s on %s" % (method_to_set, curr_entity)
    #try:
    #    getattr(record, method_to_set)(new_val)
    #except Exception as e:
    #pass

    def delete(self):
        db.session.delete(self)
        db.session.commit()

#+END_SRC


** The Data Model
   
*** Name
     
    Name is an alphabetical string.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Name(object):
    def __init__(self, value):
        # if the string contains any non-alphabet and non-space character, raise
        # a type error
        if re.search('[^a-zA-Z. ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC

*** Email

     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].  Following
     is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Email(object):
    def __init__(self, value):
        if not re.search('[^@]+@[^@]+\.[^@]+', value):
            raise TypeError('%s is not an email!' % value)
        self.value = value
#+END_SRC

*** Role
**** Immutable data
     + Id

**** Mutable data
     + Role Name

**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Role(Entity):

    __tablename__ = 'roles'

    id = db.Column(db.Integer, primary_key=True)
    role_name = db.Column(db.String(128), nullable=False)

#+END_SRC

**** Constructor
#+BEGIN_EXAMPLE
    role = Role(name=<instance of class Name>)
                    
#+END_EXAMPLE
#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'role_name' not in kwargs:
            raise AttributeRequired("mandatory attribute `role_name` is missing")
        self.set_role_name(kwargs['role_name'])

#+END_SRC

**** Functions that operate on the Workshop Document domain
***** getName: Role --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_role_name(self):
        return self.role_name
#+END_SRC

***** setName: Role, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=Name)
    def set_role_name(self, name):
        self.role_name = name
#+END_SRC



***  User
**** Immutable data
     + Id

**** Mutable data
     + Name
     + Path

**** Definition
#+BEGIN_SRC 
class WorkshopDocument(Entity):

    __tablename__ = 'workshop_documents'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    path = db.Column(db.String(128), nullable=False)

#+END_SRC

**** Constructor
#+BEGIN_EXAMPLE
    workshop_document = WorkshopDocument(name=<instance of class Name>,
                                         path=str)
                                            
#+END_EXAMPLE
#+BEGIN_SRC 
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("mandatory attribute `name` is missing")
        self.set_name(kwargs['name'])

        if 'path' not in kwargs:
            raise AttributeRequired("mandatory attribute `path` is missing")
        self.set_path(kwargs['path'])

#+END_SRC
     
**** Functions that operate on the Workshop Document domain
***** getName: WorkshopDocument --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

***** getPath: WorkshopDocument --> String
#+BEGIN_SRC 
    def get_path(self):
        return self.path
#+END_SRC

***** setName: WorkshopDocument, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name
#+END_SRC

***** setPath: WorkshopDocument, String --> Void
#+BEGIN_SRC 
    @typecheck(path=str)
    def set_path(self, path):
        self.path = path
#+END_SRC
      

*** Workshop Document
**** Immutable data
     + Id

**** Mutable data
     + Name
     + Path

**** Definition
#+BEGIN_SRC 
class WorkshopDocument(Entity):

    __tablename__ = 'workshop_documents'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    path = db.Column(db.String(128), nullable=False)

#+END_SRC

**** Constructor
#+BEGIN_EXAMPLE
    workshop_document = WorkshopDocument(name=<instance of class Name>,
                                         path=str)
                                            
#+END_EXAMPLE
#+BEGIN_SRC 
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("mandatory attribute `name` is missing")
        self.set_name(kwargs['name'])

        if 'path' not in kwargs:
            raise AttributeRequired("mandatory attribute `path` is missing")
        self.set_path(kwargs['path'])

#+END_SRC

**** Functions that operate on the Workshop Document domain
***** getName: WorkshopDocument --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

***** getPath: WorkshopDocument --> String
#+BEGIN_SRC 
    def get_path(self):
        return self.path
#+END_SRC

***** setName: WorkshopDocument, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name
#+END_SRC

***** setPath: WorkshopDocument, String --> Void
#+BEGIN_SRC 
    @typecheck(path=str)
    def set_path(self, path):
        self.path = path
#+END_SRC
      
** Custom Exceptions

These are some of the custom exceptions used in the application.
*** AttributeRequired
#+BEGIN_SRC python :tangle src/op_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC

** Utility Functions
#+BEGIN_SRC python :tangle src/utils.py :eval no
# module to hold all utilities/helper functions

import json

from flask import make_response, current_app


# return a list of dicts as json with correct mime types
# flask does not provide a jsonify for lists; hence this method
def jsonify_list(data):
    if type(data) is not list:
        raise Exception('jsonify_list function accepts only a list')

    return make_response(json.dumps(data), 200,
                         {'content-type': 'application/json'})


# take in a flask request object and try to parse out a dictionary from the
# request
# try to find if request is as JSON first, then look into forms, finally force
# find it.
# If not found return a dict; else return the parsed data
def parse_request(request):
    if request.json:
        # print 'found in request.json'
        data = request.get_json()

    elif request.data:
        # print 'found in request.data'
        data = json.loads(request.data)

    elif request.form:
        # print 'found in request.form'
        data = request.form.to_dict()
        # try to detect if form contains integers and boolean data and attempt
        # to convert them
        # FIXME: is this a good idea? Fix this to do it in a better way?
        for k in data:
            if is_number(data[k]):
                data[k] = int(data[k])
            if is_bool_in_str(data[k]):
                data[k] = str_to_bool(data[k])

            # print k, data[k]

    else:
        data = request.get_json(force=True)

    if not data:
        return False

    return data


# check if a given string is a number
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


# check if in a given string python bool types are represented
def is_bool_in_str(s):
    if s == "True" or s == "False":
        return True
    return False


# convert python bool types in string to native bool types
def str_to_bool(s):
    if s == "True":
        return True
    if s == "False":
        return False
    return None


# decorator to do typechecking of arguments passed to functions
# usage: @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
#        def yourfunc(var1, var2, ..):
#           ....
def typecheck(**typemap):
    """
    Decorator to do typechecking of arguments passed to functions. Similar to
    function annotations in Python 3, but this also does strict type checking
    when a function is called.
    The type to an argument can be single or multiple types. Mutiple types are
    to be specified in a tuple.
    Usage:
        @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
        def yourfunc(var1, var2, ..):
            ....
    """
    # print "all valid types: %s" % typemap

    def make_wrapper(decorated_func):

        def wrapper(*arg_vals, **kw_vals):
            # TODO: have more comments to better describe each line
            arg_names = decorated_func.func_code.co_varnames
            # print arg_names
            # if not arg_vals:
            #     print kw_vals
            #     # arg_vals = kw_vals
            # print arg_vals

            # iterate over the typemap passed to the typecheck decorator and
            # compare with the actual arguments passed to the function
            for key, val in typemap.iteritems():
                arg_name = key
                idx = arg_names.index(arg_name)
                arg = arg_vals[idx]
                # print "arg_name: %s, arg: %s, typemap[arg_name]: %s" %\
                #    (arg_name, arg, typemap[arg_name])

                # if the passed type is a list throw an error
                if typemap[arg_name] is list:
                    raise SyntaxError("The types of %s has to be a tuple, "
                                      "not list. \n See usage of `typecheck`" %
                                      arg_name)

                # check if the passed type is a tuple, if not make it
                if typemap[arg_name] is not tuple:
                    types = (typemap[arg_name],)
                else:
                    types = typemap[arg_name]

                # iterate over the `types` tuple to see the arg matches any of
                # the type provided in the tuple
                if True not in map(lambda type: isinstance(arg, type), types):
                    # print "types are not fine"
                    raise TypeError("For %s type should have been %s. But "
                                    "provided: %s" % (arg_name,
                                                      typemap[arg_name],
                                                      type(arg)))

            return decorated_func(*arg_vals, **kw_vals)
        return wrapper

    return make_wrapper

#+END_SRC

** The web application
#+BEGIN_SRC python :tangle src/app.py :eval no
# -*- coding: utf-8 -*-

import os

from flask import Flask, jsonify, make_response
# from flask.ext.cors import CORS

from db import db
from api import api
# import config file
import config


def create_app(config):
    # init our app
    app = Flask(__name__)

    # load config values from the config file
    app.config.from_object(config)

    # init sqlalchemy db instance
    db.init_app(app)
    db.app = app

    # register blueprints
    app.register_blueprint(api)

 #   configure_errorhandlers(app)
 #   configure_cors(app)
 #   configure_logging(app)

    # all set; return app object
    return app


if __name__ == "__main__":
    app = create_app(config)
    app.run(debug=True, host='0.0.0.0')

#+END_SRC

** Configuring the application
Below is the configuration for the application
#+BEGIN_SRC python :tangle src/config.py :eval no
# DB URI
# example DB URI:
# mysql+oursql://scott:tiger@localhost/mydatabase
# postgresql+psycopg2://scott:tiger@localhost/mydatabase
SQLALCHEMY_DATABASE_URI = 'mysql+oursql://<userid>:<password>@<servername>/<db_name>'
# example
#SQLALCHEMY_DATABASE_URI = 'mysql+oursql://root:mysql@localhost/outreach'

# Debug from SQLAlchemy
# Turn this to False on production
SQLALCHEMY_ECHO = True

# List of allowed origins for CORS
#ALLOWED_ORIGINS = ["*.vlabs.ac.in", "*.virtual-labs.ac.in"]

# List of allowed IPs
WHITELIST_IPS = ["127.0.0.1"]

# Configure your log paths
#LOG_FILE = 'outreach.log'

# Log level for the application
#LOG_LEVEL = 'DEBUG'

# destination for uploaded files
#UPLOAD_FOLDER = 'src/static/temp'

# allowed file extensions that can be uploaded
#ALLOWED_EXTENSIONS = set(['csv'])

#+END_SRC


** Model Diagram
    The model-diagram can be found below. This gives an overview of the
    relationships between different entities.

    [[https://github.com/vlead/outreach-portal/blob/develop/src/diagrams/outreach-model-diagram.jpg][Model-diagram]] 

    This diagram highlights the following facts:

    + An outreach coordinator can have multiple nodal coordinators
      associated with it.

    + An outreach coordinator can conduct multiple nodal coordinator
      trainings.

    + Each nodal centre is assigned to a unique nodal coordinator.
  
    + A nodal coordinator can conduct multiple workshops.

    + A workshop report is unique to a workshop and there can not be
      multiple reports for a single workshop.

    + Each workshop report can have multiple workshop photos.

    + The workshop document is a separate entity and is only used by an
      admin.

** REST APIs
*** Some code..
   The Python code to have the imports, boilerplate code etc. for the
   APIs.  We are using Flask blueprints to make the API, and then we
   can plug this blueprint in our main application. [[http://flask.pocoo.org/docs/0.10/blueprints/][More on Flask
   blueprints]].
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
# -*- coding: utf-8 -*-

import os
import csv

from flask import Blueprint, request, jsonify, abort, current_app, redirect,\
    url_for

from db import *
from utils import parse_request, jsonify_list
# from maps import *
api = Blueprint('APIs', __name__)

#+END_SRC

*** Implementation
   Look up table would be like (this is an example, not the
   implementation):
#+BEGIN_SRC python
  entity_map = {
      'roles': Role
  }
#+END_SRC

**** The entity look up table with corresponding types of their attributes
#+NAME: entity-map-types
#+BEGIN_SRC python
entity_map_types = {
    'roles': {
        'entity': Role,
        'types': {
            'role_name': Name
          }
    }
}
#+END_SRC

**** The API to update/delete entries
***** API route definition
The API route definitions. Defining the =/entity/id= API for update and delete
operations. The following API handler first checks if the requested URL is a
valid entity. If not it sends back a HTTP 400. If it is a valid entity, then
it looks at the HTTP method, and calls the appropriate function to actually
delete or update an existing record.
#+NAME: modify-entity
#+BEGIN_SRC python
@api.route('/<entity>/<id>', methods=['PUT', 'DELETE'])
def modify_entity(entity, id):
    if entity not in entity_map_types:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    if request.method == 'DELETE':
       status = delete_record(curr_entity, id)
       return status

    if request.method == 'PUT':
        status = update_record(entity, curr_entity, id)
        return status
#+END_SRC

***** Delete Record function
The function to delete a record given an entity and a id. On success, it
returns the =id= and a ~status=success~ as a JSON. If no such record with the
given =id= is found, it return a HTTP 404 not found error. If the record is
found, but there was error deleting the record, it sends back a HTTP 500 with
corresponding error.
#+NAME: delete-record
#+BEGIN_SRC python
def delete_record(entity, id):
    record = entity.get_by_id(id)
    if not record:
        abort(404, 'No %s with id %s' % (entity, id))
    else:
        try:
            record.delete()
            #db.session.delete(record)
            #db.session.commit()
        except Exception, e:
            print e
            abort(500, str(e))

    return jsonify(id=id, status="success")
#+END_SRC

***** Update Record function
The function to update an record given the entity name, the actual entity,
=id= of the record and the request object which has the data to be updated.
Following steps:
1. Check if the record with given =id= exist.
   1. If record doesn't exist, send back a HTTP 404 error.
2. If record exist, parse the request data into a =dict=, if the =dict= is
   empty or malformed send back a HTTP 400 error.
3. Now the request =dict= contains the request data, but they are all in
   strings. To handover the data to actually operate on to update, the data
   has to be converted to correct types, looking at the lookup table which has
   the type information. This type conversion is handled by the function
   =typecast_data=.
4. Once, the data is type converted, it calls the =update= method on the
   record.
5. If the =update= is not successful, it will send back a HTTP 500 with
   corresponding error.
6. If success, it will send back a JSON with the updated record.
#+NAME: update-record
#+BEGIN_SRC python
def update_record(entity_name, entity, id):
    record = entity.get_by_id(id)

    if not record:
        abort(404, 'No %s with id %s' % (entity_name, id))

    data = parse_request(request)
    if not data or type(data) is not dict:
        abort(400, "The data should be in JSON format")

    data = typecast_data(entity_name, data)
    print "updated, typecasted data: %s" % data

    try:
        print "Updating record: %s with data: %s" % (record, data)
        record.update(**data)
    except Exception, e:
        print e
        abort(500, str(e))

    return jsonify(record.to_client())
#+END_SRC

***** Typecast Data function
The method to typecast the data. It takes in an entity, and the data in a
=dict= format; and returns another =dict= with all the values having correct
types, based on the passed entity (this information is stored in the lookup
table with entity, its attributes and their type information). The following
functions just takes each item in the data =dict=, finds out its corresponding
constructor from the type information and calls the =typecast_item= function
over it.
#+NAME: typecast-data
#+BEGIN_SRC python
def typecast_data(entity, data):
    updated_data = {}
    for attr, val in data.iteritems():
        print "attr: %s, val: %s" % (attr, val)
        if attr not in entity_map_types[entity]['types']:
            abort(400, '%s attribute not in %s' % (attr, entity))
        const = entity_map_types[entity]['types'][attr]
        print "const for %s is %s" % (attr, const)

        if type(val) is list:
            new_val = map(lambda item: typecast_item(const, attr, item), val)
        else:
            new_val = typecast_item(const, attr, val)

        updated_data[attr] = new_val

    return updated_data
#+END_SRC

The function takes in a constructor, the attribute name and the actual
attribute value, and returns the new value typecasted to its correct type.
If the attribute is a compound item (like that itself is a =dict=), then it
calls the =typecast_compound_item= function. Else if it is a simple attribute
it just calls the constructor over the value. If the constructor throws an
error, the function returns a HTTP 400 error.
#+NAME: typecast-item
#+BEGIN_SRC python
# take a constructor, and attr name and the actual attribute and convert the
# attribute value to its actual type
def typecast_item(const, attr, val):
    if type(val) is dict:
        new_val = typecast_compound_item(const, attr, val)
        return new_val

    try:
        new_val = const(val)
    except TypeError:
        abort(400, '%s is not a valid %s' % (val, attr))

    print "new val after const: %s" % new_val
    return new_val
#+END_SRC

The function takes in a constructor, the attribute name and the actual
attribute value, and returns the new value typecasted to its correct type.
Here the assumption is, that the value that it has been passed is of type
=dict=, and the =dict= contains an =id= field, which means this value is an
existing record. Hence, this function calls the =get_by_id= method of the
constructor (or the type). If there is an error it sends back appropriate HTTP
error codes.
#+NAME: typecast-compound-item
#+BEGIN_SRC python
# take a constructor, and attr name and the actual attribute and convert the
# attribute value to its actual type
def typecast_compound_item(const, attr, val):
    if 'id' not in val:
        abort(400, "id attr has to be present in %s:%s" % (attr,
                                                           val))
    try:
        new_val = const.get_by_id(val['id'])
    except TypeError:
        abort(400, '%s is not a valid %s' % (val, attr))

    if not new_val:
        abort(404, 'id %s of %s is not found' % (val['id'], attr))
    print "new val after const: %s" % new_val
    return new_val

#+END_SRC

***** Code tangle
In the below, all the above code blocks are arranged in the order the python
interpreter expects them to be.
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
<<entity-map-types>>

<<delete-record>>

<<typecast-compound-item>>

<<typecast-item>>

<<typecast-data>>

<<update-record>>

<<modify-entity>>
#+END_SRC


**** The API to create new entries
***** API route definition
#+NAME: create-entity
#+BEGIN_SRC python
@api.route('/<entity>', methods=['POST'])
def create_entity(entity):
    if entity not in entity_map_types:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    status = create_record(entity, curr_entity)
    return status

#+END_SRC
***** Create Record function
#+NAME: create-record
#+BEGIN_SRC python
def create_record(entity_name, entity):

    data = parse_request(request)
    if not data or type(data) is not dict:
        abort(400, "The data should be in JSON format")

    data = typecast_data(entity_name, data)
    print "creating new, typecasted data: %s" % data

    try:
        print "Creating record: %s with data: %s" % (entity_name, data)
        new_record = entity(**data)
        new_record.save()
    except Exception, e:
        print e
        abort(500, str(e))

    return jsonify(new_record.to_client())
#+END_SRC


***** Code tangle
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
<<create-record>>
<<create-entity>>
#+END_SRC




      
=======
  1. Outreach portal has three types of users: Admin, Outreach coordinator and
     Nodal coordinator.
  2. Admin adds, updates and deletes an outreach coordinator.
  3. An outreach coordinator adds, updates and deletes an nodal coordinator.
  4. Documents
     1. Admin adds and deletes a set of documents. For the format of the
        documents refer scenarios [[./outreach-portal-scenarios.org::#document_formats][document]].
     2. Outreach coordinator views and downloads the documents uploaded by
        admin.
     3. Outreach coordinator adds and deletes his/her set of documents. 
     4. Nodal coordinator views and downloads the documents uploaded both by
        the Admin and his/her respective outreach coordinator.
  5. Dashboard
     1. Admin has a Dashboard. For ontents of the dashboard refer [[./outreach-portal-scenarios.org::#admin_dashboard][here]]
     2. Outreach coordinator has a dashboard
     3. Nodal coordinator has a dashboard.
  6. Outreach coordinator adds, updates and deletes an nodal coordinator.
  7. Outreach coordinator creates, updates and completes a workshop that is
     done in the past.
  8. Outreach coordinator creates, updates and completes an upcoming workshop.
  9. Outreach coordinator uploads a set of documents to complete a
     workshop. For the document list refer to scenarios [[./outreach-portal-scenarios.org::#workshop_documents][document]].  
  10. Outreach coordinator edits workshops created by nodal coordinator.
  11. Outreach coordinator approves the workshops conducted by nodal coordinator.
  12. Outreach coordinator views workshop history.
  13. Nodal coordinator creates a workshop. 
  14. Nodal coordinator uploads workshop documents for approval by outreach
      coordinator or cancels a workshop. 
  15. Nodal coordinator views the workshop history. 

* Design & Implementation  
** High Level Design
#+CAPTION: High Level Design Diagram
  [[./diagrams/outreach.svg]]
** [[View%20&%20Controller][View & Controller]]
** [[./backend.org][REST API & DB Layer]]
* Test Cases
* Provisioning
* Releases
** Admin Release - v2.1.0
   This release will satisfy requirements 2, 4.1, 5.1
   Release Date :: [2015-11-13 Fri]
** Nodal Coordinator Release - v2.2.0
   This release will satisfy requirements  4.4, 5.3, 13, 14, 15
   Release Date :: [2015-11-20 Fri]
** Outreach Coordinator Release - v2.3.0
   This release will satisfy requirements 3, 4.2, 4.3, 5.2, 6, 7, 8, 9, 10, 11
   and 12
   Release Date :: [2015-11-27 Fri]

>>>>>>> master
