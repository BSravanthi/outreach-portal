#+TITLE: Back end for Outreach Portal 
#+AUTHOR: VLEAD
#+DATE: [2015-10-27 Tue]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ../org-templates/level-0.org
#+options: ^:nil

* Introduction
  Outreach portal keeps track of all the outreach activities done to
  promote Virtual Labs. It also acts as a central place where all the
  documents related to workshops/trainings are stored.

* Requirements
  This release (outreach portal - admin release), fulfills the
  following requirements:

  1. Python API that acts as a wrapper to make CRUD operations on the
     entities - users, roles and workshop_documents.
  2. REST API for various applications to perform CRUD operations on
     the entities - users, roles and workshop_documents.
  
* Design & Implementation  
** Some initialization and boilerplate code
*** __init__
#+BEGIN_SRC python :tangle src/__init__.py :eval no
print "src package"
import db
import app
import config
#+END_SRC
*** imports
#+BEGIN_SRC python :tangle src/db.py :eval no
# -*- coding: utf-8 -*-

from collections import OrderedDict

from flask.ext.sqlalchemy import SQLAlchemy
from flask import current_app

import sqlalchemy.types as types

import re
from urlparse import urlparse
from datetime import datetime
import json

from op_exceptions import AttributeRequired
from utils import typecheck

db = SQLAlchemy()


# Abstract class to hold common methods
class Entity(db.Model):

    __abstract__ = True

    # save a db.Model to the database. commit it.
    def save(self):
        db.session.add(self)
        db.session.commit()

    # update the object, and commit to the database
    def update(self, **kwargs):
        for attr, val in kwargs.iteritems():
            setter_method = "set_" + attr
            try:
                self.__getattribute__(setter_method)(val)
            except Exception as e:
                raise e

        self.save()

    #print "Setting new val"
    #print "Calling %s on %s" % (method_to_set, curr_entity)
    #try:
    #    getattr(record, method_to_set)(new_val)
    #except Exception as e:
    #pass

    def delete(self):
        db.session.delete(self)
        db.session.commit()

#+END_SRC

** The Data Model
   
*** Name
     
    Name is an alphabetical string.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Name(object):
    def __init__(self, value):
        # if the string contains any non-alphabet and non-space character, raise
        # a type error
        if re.search('[^a-zA-Z. ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value

#+END_SRC

*** Email

     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].  Following
     is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Email(object):
    def __init__(self, value):
        if not re.search('[^@]+@[^@]+\.[^@]+', value):
            raise TypeError('%s is not an email!' % value)
        self.value = value
#+END_SRC
     
*** Role
**** Immutable data
     + Id

**** Mutable data
     + Role Name

**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Role(Entity):

    __tablename__ = 'roles'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)

    users = db.relationship('User', backref='role')
#+END_SRC

**** Constructor
#+BEGIN_EXAMPLE
    role = Role(name=str)
                    
#+END_EXAMPLE
#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("mandatory attribute `name` is missing")
        self.set_name(kwargs['name'])

#+END_SRC

**** Functions that operate on the Workshop Document domain
***** getRole: Id --> Role
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Role.query.get(id)

#+END_SRC

***** getAll: Nil --> set[Role]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return Role.query.all()

#+END_SRC
      
***** getName: Role --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name
#+END_SRC

***** setName: Role, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=str)
    def set_name(self, name):
        self.name = name
#+END_SRC

***** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name
        }

#+END_SRC

*** User
**** Immutable data
     + Id
     + Created
     + Last Active

**** Mutable data
     + Name
     + Email
     + Role --> Id
  
**** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class User(Entity):

    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    email = db.Column(db.String(128), unique=True)
    
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
 
    created = db.Column(db.DateTime(), default=datetime.utcnow)
    last_active = db.Column(db.DateTime(), default=datetime.utcnow)
 #+END_SRC

**** Constructor
#+BEGIN_EXAMPLE
    User = User(name=str,
                email=str,
                role=<instance of class Role>)
                                            
#+END_EXAMPLE
#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("mandatory attribute `name` is missing")
        self.set_name(kwargs['name'])

        if 'email' not in kwargs:
            raise AttributeRequired("mandatory attribute `email` is missing")
        self.set_email(kwargs['email'])

        if 'role' not in kwargs:
            raise AttributeRequired("mandatory attribute `role` is missing")
        self.set_role(kwargs['role'])
        
    def __str__(self):
        return "Name = %s, e-mail id = %s, role = %s" % \
            (self.name, self.email, self.role.name)

    def __repr__(self):
        return "Name = %s, e-mail id = %s, role = %s" % \
            (self.name, self.email, self.role.name)

#+END_SRC
     
**** Functions that operate on the Workshop Document domain
***** getAll: Nil --> set[User]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all():
        return User.query.all()

#+END_SRC
***** getUser: Id --> User
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return User.query.get(id)

#+END_SRC

***** getName: User --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name
#+END_SRC

***** getEmail: User --> Email
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_email(self):
        return self.email
#+END_SRC

***** getRole: User --> Role
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_role(self):
        return self.role

#+END_SRC

***** timeOfCreation: User --> Datetime
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_created(self):
        return self.created
#+END_SRC

***** getLastActive: User --> Datetime
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_last_active(self):
        return self.last_active
#+END_SRC

***** setName: User, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=str)
    def set_name(self, name):
        self.name = name
#+END_SRC

***** setEmail: User, Email --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(email=str)
    def set_email(self, email):
        self.email = email
#+END_SRC

***** setRole: User, Role --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(role=Role)
    def set_role(self, role):
        self.role = role

#+END_SRC

***** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'email': self.email,
            'name': self.name,
            'role': self.role.to_client(),
            'last_active': self.last_active.isoformat(),
            'created': self.created.isoformat()
        }
#+END_SRC
      
*** Workshop Document
**** Immutable data
     + Id

**** Mutable data
     + Name
     + Path

**** Definition
#+BEGIN_SRC 
class WorkshopDocument(Entity):

    __tablename__ = 'workshop_documents'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    path = db.Column(db.String(128), nullable=False)

#+END_SRC

**** Constructor
#+BEGIN_EXAMPLE
    workshop_document = WorkshopDocument(name=<instance of class Name>,
                                         path=str)
                                            
#+END_EXAMPLE
#+BEGIN_SRC 
    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("mandatory attribute `name` is missing")
        self.set_name(kwargs['name'])

        if 'path' not in kwargs:
            raise AttributeRequired("mandatory attribute `path` is missing")
        self.set_path(kwargs['path'])

#+END_SRC

**** Functions that operate on the Workshop Document domain
***** getName: WorkshopDocument --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

***** getPath: WorkshopDocument --> String
#+BEGIN_SRC 
    def get_path(self):
        return self.path
#+END_SRC

***** setName: WorkshopDocument, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name
#+END_SRC

***** setPath: WorkshopDocument, String --> Void
#+BEGIN_SRC 
    @typecheck(path=str)
    def set_path(self, path):
        self.path = path
#+END_SRC
      
** Custom Exceptions

These are some of the custom exceptions used in the application.
*** AttributeRequired
#+BEGIN_SRC python :tangle src/op_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC

** Utility Functions
#+BEGIN_SRC python :tangle src/utils.py :eval no
# module to hold all utilities/helper functions

import json

from flask import make_response, current_app


# return a list of dicts as json with correct mime types
# flask does not provide a jsonify for lists; hence this method
def jsonify_list(data):
    if type(data) is not list:
        raise Exception('jsonify_list function accepts only a list')

    return make_response(json.dumps(data), 200,
                         {'content-type': 'application/json'})


# take in a flask request object and try to parse out a dictionary from the
# request
# try to find if request is as JSON first, then look into forms, finally force
# find it.
# If not found return a dict; else return the parsed data
def parse_request(request):
    if request.json:
        # print 'found in request.json'
        data = request.get_json()

    elif request.data:
        # print 'found in request.data'
        data = json.loads(request.data)

    elif request.form:
        # print 'found in request.form'
        data = request.form.to_dict()
        # try to detect if form contains integers and boolean data and attempt
        # to convert them
        # FIXME: is this a good idea? Fix this to do it in a better way?
        for k in data:
            if is_number(data[k]):
                data[k] = int(data[k])
            if is_bool_in_str(data[k]):
                data[k] = str_to_bool(data[k])

            # print k, data[k]

    else:
        data = request.get_json(force=True)

    if not data:
        return False

    return data


# check if a given string is a number
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


# check if in a given string python bool types are represented
def is_bool_in_str(s):
    if s == "True" or s == "False":
        return True
    return False


# convert python bool types in string to native bool types
def str_to_bool(s):
    if s == "True":
        return True
    if s == "False":
        return False
    return None


# decorator to do typechecking of arguments passed to functions
# usage: @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
#        def yourfunc(var1, var2, ..):
#           ....
def typecheck(**typemap):
    """
    Decorator to do typechecking of arguments passed to functions. Similar to
    function annotations in Python 3, but this also does strict type checking
    when a function is called.
    The type to an argument can be single or multiple types. Mutiple types are
    to be specified in a tuple.
    Usage:
        @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
        def yourfunc(var1, var2, ..):
            ....
    """
    # print "all valid types: %s" % typemap

    def make_wrapper(decorated_func):

        def wrapper(*arg_vals, **kw_vals):
            # TODO: have more comments to better describe each line
            arg_names = decorated_func.func_code.co_varnames
            # print arg_names
            # if not arg_vals:
            #     print kw_vals
            #     # arg_vals = kw_vals
            # print arg_vals

            # iterate over the typemap passed to the typecheck decorator and
            # compare with the actual arguments passed to the function
            for key, val in typemap.iteritems():
                arg_name = key
                idx = arg_names.index(arg_name)
                arg = arg_vals[idx]
                # print "arg_name: %s, arg: %s, typemap[arg_name]: %s" %\
                #    (arg_name, arg, typemap[arg_name])

                # if the passed type is a list throw an error
                if typemap[arg_name] is list:
                    raise SyntaxError("The types of %s has to be a tuple, "
                                      "not list. \n See usage of `typecheck`" %
                                      arg_name)

                # check if the passed type is a tuple, if not make it
                if typemap[arg_name] is not tuple:
                    types = (typemap[arg_name],)
                else:
                    types = typemap[arg_name]

                # iterate over the `types` tuple to see the arg matches any of
                # the type provided in the tuple
                if True not in map(lambda type: isinstance(arg, type), types):
                    # print "types are not fine"
                    raise TypeError("For %s type should have been %s. But "
                                    "provided: %s" % (arg_name,
                                                      typemap[arg_name],
                                                      type(arg)))

            return decorated_func(*arg_vals, **kw_vals)
        return wrapper

    return make_wrapper

#+END_SRC

** The web application
#+BEGIN_SRC python :tangle src/app.py :eval no
# -*- coding: utf-8 -*-

import os

from flask import Flask, jsonify, make_response
# from flask.ext.cors import CORS

from db import db
from api import api
# import config file
import config


def create_app(config):
    # init our app
    app = Flask(__name__)

    # load config values from the config file
    app.config.from_object(config)

    # init sqlalchemy db instance
    db.init_app(app)
    db.app = app

    # register blueprints
    app.register_blueprint(api)

 #   configure_errorhandlers(app)
 #   configure_cors(app)
 #   configure_logging(app)

    # all set; return app object
    return app


if __name__ == "__main__":
    app = create_app(config)
    app.run(debug=True, host='0.0.0.0')

#+END_SRC

** Configuring the application
Below is the configuration for the application
#+BEGIN_SRC python :tangle src/config.py :eval no
# DB URI
# example DB URI:
# mysql+oursql://scott:tiger@localhost/mydatabase
# postgresql+psycopg2://scott:tiger@localhost/mydatabase
SQLALCHEMY_DATABASE_URI = 'mysql+oursql://<userid>:<password>@<servername>/<db_name>'
# example
#SQLALCHEMY_DATABASE_URI = 'mysql+oursql://root:mysql@localhost/outreach'

# Debug from SQLAlchemy
# Turn this to False on production
SQLALCHEMY_ECHO = True

# List of allowed origins for CORS
#ALLOWED_ORIGINS = ["*.vlabs.ac.in", "*.virtual-labs.ac.in"]

# List of allowed IPs
WHITELIST_IPS = ["127.0.0.1"]

# Configure your log paths
#LOG_FILE = 'outreach.log'

# Log level for the application
#LOG_LEVEL = 'DEBUG'

# destination for uploaded files
#UPLOAD_FOLDER = 'src/static/temp'

# allowed file extensions that can be uploaded
#ALLOWED_EXTENSIONS = set(['csv'])

#+END_SRC

** Model Diagram
    The model-diagram can be found below. This gives an overview of the
    relationships between different entities.

    [[https://github.com/vlead/outreach-portal/blob/develop/src/diagrams/outreach-model-diagram.jpg][Model-diagram]] 

    This diagram highlights the following facts:

    + An outreach coordinator can have multiple nodal coordinators
      associated with it.

    + An outreach coordinator can conduct multiple nodal coordinator
      trainings.

    + Each nodal centre is assigned to a unique nodal coordinator.
  
    + A nodal coordinator can conduct multiple workshops.

    + A workshop report is unique to a workshop and there can not be
      multiple reports for a single workshop.

    + Each workshop report can have multiple workshop photos.

    + The workshop document is a separate entity and is only used by an
      admin.

** REST APIs
*** Some code..
   The Python code to have the imports, boilerplate code etc. for the
   APIs.  We are using Flask blueprints to make the API, and then we
   can plug this blueprint in our main application. [[http://flask.pocoo.org/docs/0.10/blueprints/][More on Flask
   blueprints]].
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
# -*- coding: utf-8 -*-

import os
import csv

from flask import Blueprint, request, jsonify, abort, current_app, redirect,\
    url_for

from db import *
from utils import parse_request, jsonify_list
from maps import *
api = Blueprint('APIs', __name__)

#+END_SRC

** REST APIs to read and query data
   These are the set of REST APIs for read operations.

*** Design
   The REST APIs to get and query data are designed in a generic
   way. That is, APIs for each entity is not designed and implemented
   specifically, rather three generic API patterns are designed which,
   presumably, will capture all kinds of query patterns.

   The three API patterns are:
   1. =/<:entity>s?query_param1=val1&query_param2=val2&..query_paramn=valn=
   2. =/<:entity>s/<:id>?fields=field1,field2,field3=
   3. =/<:entity>s/<:id>/<entity>s?query_param1=val1&query_param2=val2=

   =<:entity>s= are defined in the corresponding look up table.

   Let's explain each URL pattern:
   1. The first URL pattern is to get record(s) of an entity which
      satisfies some query parameters. Note, if one does not pass any
      query parameter, it returns all records of that entity.  For
      example:
      1. To get all labs of IIIT-H at integration level 6 and hosted on
         AWS:
        #+BEGIN_EXAMPLE
	GET /labs?integration_level=6&institute=iiith&hosted_on=AWS
	#+END_EXAMPLE
      2. To get all labs in the system:
         #+BEGIN_EXAMPLE
	 GET /labs
	 #+END_EXAMPLE
      3. To get all the developers associated with IIIT-H:
         #+BEGIN_EXAMPLE
	 GET /developers?institute=iiith
	 #+END_EXAMPLE
   2. The second URL pattern is to get details of a particular record,
      identified by a unique identifier =id=. The records can be
      further filtered down with only desired attributes.  For example:
      1. Get only few details the Data Structures lab (where the lab
         id is known before):
         #+BEGIN_EXAMPLE
	 GET /labs/cse02?fields=name,institute,hosted_url
	 #+END_EXAMPLE
      2. Get all the details of particular developer (presuming the id
         is known beforehand):
         #+BEGIN_EXAMPLE
	 GET /developers/22
	 #+END_EXAMPLE
   3. The third URL pattern is to get record(s) of an entity which is
      part of another entity. Like to get experiments / technologies /
      developers of a lab, or to get labs of an institute. The
      record(s) can also be filtered on some query parameters. Like to
      get all the technologies of a lab which are non FOSS.  For
      example:
      1. Get all technologies of a lab which are non FOSS:
         #+BEGIN_EXAMPLE
	 GET /labs/cse02/technologies?foss=false
	 #+END_EXAMPLE
      2. Get all experiments of a lab which uses Java3D and Flash:
         #+BEGIN_EXAMPLE
	 GET /labs/cse02/experiments?technologies=java3d,flash
	 #+END_EXAMPLE


   Note that, nesting of entities in the URL API is only allowed till
   2nd level. Arbitrary nesting of entities might have the problem of
   falling into infinite loop while querying.

   Also note that, attributes with multiple values are
   comma-separated; and the default action is to use AND operation
   among them. If the OR operation is needed, they need to be
   substituted by '+'. Example: To get all experiments of a lab which
   uses Java3D OR Flash:
   #+BEGIN_EXAMPLE
   GET /labs/cse02/experiments?technologies=java3d+flash
   #+END_EXAMPLE

   In the above, a valid =<:entity>s= can be any of the keywords
   defined in the look up table. Like, =labs=, =disciplines=,
   =experiements=, =developers=. Note that the entity name is always
   plural, but the look up table maps the plural keyword to a
   particular entity (which is usually in singular form).

   Look up table would be like (this is an example, not the
   implementation):
#+BEGIN_SRC python
  entity_map = {
      'roles': Role,
      'users': User
    }
#+END_SRC

   **TODO**: usage documentation of all REST APIs for the consumers of
   data service has to be written down somewhere and published.

*** Implementation
**** Attributes of an entity and their relationship
     All the attributes of an entity and the relationship between the entity
     and the attribute is captured to facilitate run time creation of queries.

#+BEGIN_SRC python :tangle src/maps.py :eval no
from db import *
role = {'entity_class': Role,
        'attributes': [
            {'name': 'id',
             'class': None,
             'relationship': 'one'},
            {'name': 'name',
             'class': None,
             'relationship': 'one'},
            {'name': 'users',
             'class': User,
             'relationship': 'many'}
            ]}

user = {'entity_class': User,
        'attributes': [
            {'name': 'id',
             'class': None,
             'relationship': 'one'},
            {'name': 'name',
             'class': None,
             'relationship': 'one'},
            {'name': 'email',
             'class': None,
             'relationship': 'one'},
            {'name': 'created',
             'class': None,
             'relationship': 'one'},
            {'name': 'last_active',
             'class': None,
             'relationship': 'one'},
            {'name': 'role',
             'class': Role,
             'relationship': 'many'}
             ]}


roles = role
users = user

entity_pairs = {
    'roles': role,
    'users': user
}
                   
#+END_SRC

**** GET APIS
#+BEGIN_SRC python :tangle src/api.py :eval no
# query an entity
# =/<:entity>s?query_param1=val1&query_param2=val2&..query_paramn=valn=
@api.route('/<entity>', methods=['GET'])
def query_an_entity(entity):
    if entity not in entity_pairs:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_pairs[entity]['entity_class']
    arg_tuple_list = request.args.lists()
    if not arg_tuple_list:
        print "data: %s" % [i.to_client() for i in curr_entity.get_all()]
        return jsonify_list([i.to_client() for i in curr_entity.get_all()])
    else:
        query = curr_entity.query
        filters = []
        for arg_tuple in arg_tuple_list:
            args = arg_tuple[0].split('.')
            values = arg_tuple[1][0].split(',')
            filters.append(create_filters(entity_pairs[entity],
                                          curr_entity,
                                          args,
                                          values))
        for filter in filters:
            query = query.filter(filter)
        entities = query.all()
        print "data: %s" % [ent.to_client() for ent in entities]
        return jsonify_list([ent.to_client() for ent in entities])


def create_filters(entity_map, curr_entity, args, values):
    if len(args) == 1:
        try:
            return getattr(curr_entity, args[0]).in_(values)
        except Exception, e:
            abort(400, 'error is %s' % (str(e)))
    else:
        result = filter(lambda item: item['name'] == args[0],
                        entity_map['attributes'])
        if not result:
            abort(400, '%s is not attribute of %s' %
                  (args[0], str(entity_map['entity_class'])))

        entity_map = args[0]
        if result[0]['relationship'] == 'one':
            try:
                return getattr(curr_entity, args[0]).has(
                    create_filters(entity_map,
                                   result[0]['class'],
                                   args[1:],
                                   values))
            except Exception, e:
                abort(400, 'error is %s' % (str(e)))
        else:
            try:
                return getattr(curr_entity, args[0]).any(
                    create_filters(entity_map,
                                   result[0]['class'],
                                   args[1:],
                                   values))
            except Exception, e:
                abort(400, 'error is %s' % (str(e)))


@api.route('/<entity>/<id>', methods=['GET'])
def get_specific_entity(entity, id):
    if entity not in entity_pairs:
        abort(400, 'Entity %s is not valid.' % entity)
    curr_entity = entity_pairs[entity]['entity_class']
    record = curr_entity.get_by_id(id)
    if not record:
        abort(404, "No entry for %s with id: %s found." % (entity, id))

    return jsonify(record.to_client())

#+END_SRC

** REST API to create/update/delete data
*** Design
*** Implementation
**** The entity look up table with corresponding types of their attributes
#+NAME: entity-map-types
#+BEGIN_SRC python
entity_map_types = {
    'roles': {
        'entity': Role,
        'types': {
            'name': str
          }
    },
    'users': {
        'entity': User,
        'types': {
            'name': str,
            'email': str,
            'role': Role,
            'last_active': datetime,
            'created': datetime
          }
    }
}
#+END_SRC

**** The API to update/delete entries
***** API route definition
The API route definitions. Defining the =/entity/id= API for update and delete
operations. The following API handler first checks if the requested URL is a
valid entity. If not it sends back a HTTP 400. If it is a valid entity, then
it looks at the HTTP method, and calls the appropriate function to actually
delete or update an existing record.
#+NAME: modify-entity
#+BEGIN_SRC python
@api.route('/<entity>/<id>', methods=['PUT', 'DELETE'])
def modify_entity(entity, id):
    if entity not in entity_map_types:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    if request.method == 'DELETE':
       status = delete_record(curr_entity, id)
       return status

    if request.method == 'PUT':
        status = update_record(entity, curr_entity, id)
        return status
#+END_SRC

***** Delete Record function
The function to delete a record given an entity and a id. On success, it
returns the =id= and a ~status=success~ as a JSON. If no such record with the
given =id= is found, it return a HTTP 404 not found error. If the record is
found, but there was error deleting the record, it sends back a HTTP 500 with
corresponding error.
#+NAME: delete-record
#+BEGIN_SRC python
def delete_record(entity, id):
    record = entity.get_by_id(id)
    if not record:
        abort(404, 'No %s with id %s' % (entity, id))
    else:
        try:
            record.delete()
            #db.session.delete(record)
            #db.session.commit()
        except Exception, e:
            print e
            abort(500, str(e))

    return jsonify(id=id, status="success")
#+END_SRC

***** Update Record function
The function to update an record given the entity name, the actual entity,
=id= of the record and the request object which has the data to be updated.
Following steps:
1. Check if the record with given =id= exist.
   1. If record doesn't exist, send back a HTTP 404 error.
2. If record exist, parse the request data into a =dict=, if the =dict= is
   empty or malformed send back a HTTP 400 error.
3. Now the request =dict= contains the request data, but they are all in
   strings. To handover the data to actually operate on to update, the data
   has to be converted to correct types, looking at the lookup table which has
   the type information. This type conversion is handled by the function
   =typecast_data=.
4. Once, the data is type converted, it calls the =update= method on the
   record.
5. If the =update= is not successful, it will send back a HTTP 500 with
   corresponding error.
6. If success, it will send back a JSON with the updated record.
#+NAME: update-record
#+BEGIN_SRC python
def update_record(entity_name, entity, id):
    record = entity.get_by_id(id)

    if not record:
        abort(404, 'No %s with id %s' % (entity_name, id))

    data = parse_request(request)
    if not data or type(data) is not dict:
        abort(400, "The data should be in JSON format")

    data = typecast_data(entity_name, data)
    print "updated, typecasted data: %s" % data

    try:
        print "Updating record: %s with data: %s" % (record, data)
        record.update(**data)
    except Exception, e:
        print e
        abort(500, str(e))

    return jsonify(record.to_client())
#+END_SRC

****** Typecast Data function
The method to typecast the data. It takes in an entity, and the data in a
=dict= format; and returns another =dict= with all the values having correct
types, based on the passed entity (this information is stored in the lookup
table with entity, its attributes and their type information). The following
functions just takes each item in the data =dict=, finds out its corresponding
constructor from the type information and calls the =typecast_item= function
over it.
#+NAME: typecast-data
#+BEGIN_SRC python
def typecast_data(entity, data):
    updated_data = {}
    for attr, val in data.iteritems():
        print "attr: %s, val: %s" % (attr, val)
        if attr not in entity_map_types[entity]['types']:
            abort(400, '%s attribute not in %s' % (attr, entity))
        const = entity_map_types[entity]['types'][attr]
        print "const for %s is %s" % (attr, const)

        if type(val) is list:
            new_val = map(lambda item: typecast_item(const, attr, item), val)
        else:
            new_val = typecast_item(const, attr, val)

        updated_data[attr] = new_val

    return updated_data
#+END_SRC

The function takes in a constructor, the attribute name and the actual
attribute value, and returns the new value typecasted to its correct type.
If the attribute is a compound item (like that itself is a =dict=), then it
calls the =typecast_compound_item= function. Else if it is a simple attribute
it just calls the constructor over the value. If the constructor throws an
error, the function returns a HTTP 400 error.
#+NAME: typecast-item
#+BEGIN_SRC python
# take a constructor, and attr name and the actual attribute and convert the
# attribute value to its actual type
def typecast_item(const, attr, val):
    if type(val) is dict:
        new_val = typecast_compound_item(const, attr, val)
        return new_val

    try:
        new_val = const(val)
    except TypeError:
        abort(400, '%s is not a valid %s' % (val, attr))

    print "new val after const: %s" % new_val
    return new_val
#+END_SRC

The function takes in a constructor, the attribute name and the actual
attribute value, and returns the new value typecasted to its correct type.
Here the assumption is, that the value that it has been passed is of type
=dict=, and the =dict= contains an =id= field, which means this value is an
existing record. Hence, this function calls the =get_by_id= method of the
constructor (or the type). If there is an error it sends back appropriate HTTP
error codes.
#+NAME: typecast-compound-item
#+BEGIN_SRC python
# take a constructor, and attr name and the actual attribute and convert the
# attribute value to its actual type
def typecast_compound_item(const, attr, val):
    if 'id' not in val:
        abort(400, "id attr has to be present in %s:%s" % (attr,
                                                           val))
    try:
        new_val = const.get_by_id(val['id'])
    except TypeError:
        abort(400, '%s is not a valid %s' % (val, attr))

    if not new_val:
        abort(404, 'id %s of %s is not found' % (val['id'], attr))
    print "new val after const: %s" % new_val
    return new_val

#+END_SRC

***** Code tangle
In the below, all the above code blocks are arranged in the order the python
interpreter expects them to be.
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
<<entity-map-types>>

<<delete-record>>

<<typecast-compound-item>>

<<typecast-item>>

<<typecast-data>>

<<update-record>>

<<modify-entity>>
#+END_SRC


**** The API to create new entries
***** API route definition
#+NAME: create-entity
#+BEGIN_SRC python
@api.route('/<entity>', methods=['POST'])
def create_entity(entity):
    if entity not in entity_map_types:
        abort(400, 'Entity %s is not valid.' % entity)

    curr_entity = entity_map_types[entity]['entity']

    status = create_record(entity, curr_entity)
    return status

#+END_SRC
***** Create Record function
#+NAME: create-record
#+BEGIN_SRC python
def create_record(entity_name, entity):

    data = parse_request(request)
    if not data or type(data) is not dict:
        abort(400, "The data should be in JSON format")

    data = typecast_data(entity_name, data)
    print "creating new, typecasted data: %s" % data

    try:
        print "Creating record: %s with data: %s" % (entity_name, data)
        new_record = entity(**data)
        new_record.save()
    except Exception, e:
        print e
        abort(500, str(e))

    return jsonify(new_record.to_client())
#+END_SRC


***** Code tangle
#+BEGIN_SRC python :tangle src/api.py :eval no :noweb yes
<<create-record>>
<<create-entity>>
#+END_SRC




